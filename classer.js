"use strict";


/**
 * Main entry point
 */

if (typeof module === "undefined" || !module || typeof module.exports === "undefined") {
  window.Classer = Classer;
}
else {
  module.exports = exports = Classer;
}

function Classer (descriptors) {
  return Classer.create(descriptors);
}


/**
 * Make a class with the given property descriptors.
 *
 * @param  {Object}   descriptors An object containing the property descriptors for the class.
 * @return {Function}             The created class.
 */
Classer.create = function (descriptors) {
  descriptors = descriptors || {};

  var Class = this.makeConstructor();

  this.makeStatic(Class, descriptors);
  this.makePrototype(Class, descriptors);

  return Class;
};

/**
 * Make a constructor for a class.
 * @return {Function} The constructor function.
 */
Classer.makeConstructor = function () {
  function Class (config) {
    if (!(this instanceof Class)) {
      return new Class(config);
    }
    this.applyDefaults();
    if (config) {
      this.configure(config);
    }
    this.initialize();
  }

  return Class;
};

/**
 * Make the static methods for a class.
 *
 * @param  {Function} Class        The class itself.
 * @param  {Object}   descriptors  The property descriptors for the class.
 */
Classer.makeStatic = function (Class, descriptors) {
  var Classer = this; // to allow subclassing
  Object.defineProperties(Class, {
    /**
     * Create a new instance of the class.
     */
    create: {
      configurable: true,
      value: function (properties) {
        return new Class(properties);
      }
    },
    /**
     * Get the descriptors of the class.
     */
    descriptors: {
      value: descriptors
    },
    /**
     * Define a new property on the class.
     */
    defineProperty: {
      configurable: true,
      value: function (name, descriptor, skipReload) {
        descriptor = descriptor || {value: null};
        if (typeof descriptor === 'function') {
          // this is a method
          descriptor = {
            enumerable: false,
            configurable: true,
            writable: true,
            value: descriptor
          };
        }

        if (descriptor.value === undefined && !(descriptor.get || descriptor.set)) {
          descriptor.value = null;
        }

        if (descriptor.writable == null && descriptor.value !== undefined) {
          descriptor.writable = true;
        }
        if (descriptor.enumerable == null) {
          descriptor.enumerable = true;
        }
        if (descriptor.configurable == null) {
          descriptor.configurable = true;
        }
        descriptors[name] = descriptor;
        Object.defineProperty(this.prototype, name, descriptor);
        if (!skipReload) {
          if (!this.prototype.applyDefaults || this.prototype.applyDefaults.isAutoGenerated) {
            this.prototype.applyDefaults = Class.makeApplyDefaults(descriptors);
          }
          if (!this.prototype.configure || this.prototype.configure.isAutoGenerated) {
            this.prototype.configure = Class.makeConfigure(descriptors);
          }
          if (!this.prototype.toJSON || this.prototype.toJSON.isAutoGenerated) {
            this.prototype.toJSON = Class.makeToJSON(descriptors);
          }
        }
        return this;
      }
    },
    /**
     * Define a list of properties on the class.
     */
    defineProperties: {
      configurable: true,
      value: function (items) {
        if (!items) {
          return this;
        }
        var keys = Object.keys(items),
            total = keys.length,
            key, i;

        for (i = 0; i < total; i++) {
          key = keys[i];
          this.defineProperty(key, items[key], true);
        }
        if (!this.prototype.applyDefaults || this.prototype.applyDefaults.isAutoGenerated) {
          this.prototype.applyDefaults = Class.makeApplyDefaults(descriptors);
        }
        if (!this.prototype.configure || this.prototype.configure.isAutoGenerated) {
          this.prototype.configure = Class.makeConfigure(descriptors);
        }
        if (!this.prototype.toJSON || this.prototype.toJSON.isAutoGenerated) {
          this.prototype.toJSON = Class.makeToJSON(descriptors);
        }
        return this;
      }
    },
    /**
     * Inherit descriptors from another class.
     */
    inherits: {
      configurable: true,
      value: function (Super) {
        var keys = Object.keys(Super),
            total = keys.length,
            key, i;


        for (i = 0; i < total; i++) {
          key = keys[i];
          if (!this.hasOwnProperty(key)) {
            this[key] = Super[key];
          }
        }
        var superDescriptors = Super.descriptors || {};
        keys = Object.keys(superDescriptors);
        total = keys.length;
        for (i = 0; i < total; i++) {
          key = keys[i];
          if (!descriptors.hasOwnProperty(key)) {
            descriptors[key] = superDescriptors[key];
          }
        }
        descriptors.super = {
          enumerable: false,
          value: Super.prototype
        };
        this.prototype = Object.create(Super.prototype, descriptors);
        this.prototype.constructor = this;

        if (!this.prototype.applyDefaults || this.prototype.applyDefaults.isAutoGenerated) {
          this.prototype.applyDefaults = Class.makeApplyDefaults(descriptors);
        }
        if (!this.prototype.configure || this.prototype.configure.isAutoGenerated) {
          this.prototype.configure = Class.makeConfigure(descriptors);
        }
        if (!this.prototype.toJSON || this.prototype.toJSON.isAutoGenerated) {
          this.prototype.toJSON = Class.makeToJSON(descriptors);
        }

        return this;
      }
    },
    /**
     * Create a new class which extends from this one.
     */
    extend: {
      configurable: true,
      value: function (config) {
        var Child = Classer.create(config);
        Child.inherits(this);
        return Child;
      }
    },
    /**
     * Mix the properties from a source object into this one.
     * @type {Object}
     */
    mixin: {
      configurable: true,
      value: function (source) {
        var keys = Object.keys(source),
            total = keys.length,
            combined = {},
            key, i;

        for (i = 0; i < total; i++) {
          key = keys[i];
          combined[key] = {
            value: source[key]
          };
        }
        this.defineProperties(combined);
        return this;
      }
    },
    makeApplyDefaults: {
      configurable: true,
      /**
       * Make an efficient `applyDefaults()` function to set
       * the default property values for a class instance.
       *
       * @param  {Object} descriptors The descriptors for the object.
       * @return {Function}           The `applyDefaults()` function.
       */
      value: function (descriptors) {
        var keys = Object.keys(descriptors),
            total = keys.length,
            body = '',
            key, descriptor, i, suffix, value;

        for (i = 0; i < total; i++) {
          key = keys[i];
          descriptor = descriptors[key];
          if (descriptor.hasOwnProperty('default')) {
            suffix = '';
            if (typeof descriptor.default === 'function') {
              suffix = '(this)';
            }
            if (/^([\w|_|$]+)$/.test(key)) {
              body += 'this.' + key + ' = this.constructor.descriptors.' + key + '.default' + suffix + ';';
            }
            else {
              body += 'this["' + key + '"] = this.constructor.descriptors["' + key + '"].default' + suffix + ';';
            }
          }
          else if (descriptor.bind) {
            if (/^([\w|_|$]+)$/.test(key)) {
              if (descriptor.bind === true) {
                value = 'this';
              }
              else {
                value = 'this.constructor.descriptors.' + key + '.bind';
              }
              body += 'this.' + key + ' = this.' + key + '.bind(' + value + ');';
            }
            else {
              if (descriptor.bind === true) {
                value = 'this';
              }
              else {
                value = 'this.constructor.descriptors["' + key + '"].bind';
              }
              body += 'this["' + key + '"] = this["' + key + '"].bind(' + value + ');';
            }
          }
        }
        var applyDefaults = new Function(body); // jshint ignore:line
        applyDefaults.isAutoGenerated = true;
        return applyDefaults;
      }
    },
    makeConfigure: {
      configurable: true,
      /**
       * Make an efficient `configure()` function to set property values
       * for an object based on the given descriptors.
       *
       * @param  {Object} descriptors The descriptors for the object.
       * @return {Function}           The `configure()` function.
       */
      value: function (descriptors) {
        var keys = Object.keys(descriptors),
            total = keys.length,
            body = '',
            key, descriptor, i;

        for (i = 0; i < total; i++) {
          key = keys[i];
          descriptor = descriptors[key];
          if (descriptor.writable || descriptor.hasOwnProperty('set')) {
            if (/^([\w|_|$]+)$/.test(key)) {
              body += 'this.' + key + ' = config.' + key + ' !== undefined ? config.' + key + ' : this.' + key + ';'; // jshint ignore:line
            }
            else {
              body += 'this["' + key + '"] = config["' + key + '"] !== undefined ? config["' + key + '"] : this["' + key + '"];'; // jshint ignore:line
            }
          }
        }
        var configure = new Function('config', body); // jshint ignore:line
        configure.isAutoGenerated = true;
        return configure;
      }
    },
    makeToJSON: {
      configurable: true,
      /**
       * Make an efficient `toJSON()` function for an object
       * based on the given descriptors.
       *
       * @param  {Object} descriptors The descriptors for the object.
       * @return {Function}           The `toJSON()` function.
       */
      value: function (descriptors) {
        var keys = Object.keys(descriptors),
            total = keys.length,
            parts = [],
            key, descriptor, i;

        for (i = 0; i < total; i++) {
          key = keys[i];
          descriptor = descriptors[key];
          if (descriptor.enumerable || descriptor.enumerable == null) {
            if (/^([\w|_|$]+)$/.test(key)) {
              parts.push(key + ': this.' + key);
            }
            else {
              parts.push('"' + key + '": this["' + key + '"]');
            }
          }
        }
        var toJSON = new Function('return {' + parts.join(',') + '};'); // jshint ignore:line
        toJSON.isAutoGenerated = true;
        return toJSON;
      }
    }
  });
};

/**
 * Make a prototype for a class, based on the given descriptors.
 *
 * @param  {Function} Class       The class itself.
 * @param  {Object} descriptors   The descriptors for the class.
 */
Classer.makePrototype = function (Class, descriptors) {
  Class.defineProperties(descriptors);
  if (!descriptors.initialize) {
    Class.defineProperty('initialize', {
      value: function () {}
    });
  }

  // don't overwrite custom applyDefaults functions if supplied.
  if (!descriptors.applyDefaults) {
    Object.defineProperty(Class.prototype, 'applyDefaults', {
      configurable: true,
      writable: true,
      value: Class.makeApplyDefaults(descriptors)
    });
  }

  // don't overwrite custom configure functions if supplied.
  if (!descriptors.configure) {
    Object.defineProperty(Class.prototype, 'configure', {
      configurable: true,
      writable: true,
      value: Class.makeConfigure(descriptors)
    });
  }

  // don't overwrite custom toJSON functions if supplied.
  if (!descriptors.toJSON) {
    Object.defineProperty(Class.prototype, 'toJSON', {
      configurable: true,
      writable: true,
      value: Class.makeToJSON(descriptors)
    });
  }
};

/**
 * Extend the class factory.
 *
 * @param  {Object} descriptors The descriptors for the new class factory.
 * @return {Classer}            The class factory
 */
Classer.extend = function (descriptors) {
  descriptors = descriptors || {};
  var keys = Object.keys(descriptors),
      total = keys.length,
      i, key;

  for (i = 0; i < total; i++) {
    key = keys[i];
    if (typeof descriptors[key] === "function") {
      descriptors[key] = {
        configurable: true,
        value: descriptors[key]
      };
    }
  }
  var Child = Object.create(this, descriptors);
  Child.super = this;
  return Child;
};